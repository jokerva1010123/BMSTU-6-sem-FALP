**Функция** - однозначное отображение множества значений аргументов в значение функции.  
**Функциональный язык** -  тот, который базируется на понятии функции.  
**Функциональность системы** - предоставляемые пользователю возможности.  

# Классификация функций
## По аргументам и поведению (Основная)
* **Базовые/чистые функции**, фиксированное кол-во аргументов, для определенного набора аргументов один фиксированный результат. 
* **Формы** - ф-и, которые принимают произвольное количество аргументов или по разному
обрабатывают аргументы.
* **[Функционалы](Функционалы-Lisp)** (высшего порядка) - в качестве аргумента принимают функцию или возвращают функцию.

## По именованию
* **Именованные** - есть имя, можно определить через defun.
   *Специальные символы(T, Nil) и самоопределимые атомы (натуральные, вещественные числа, строки) не могут выступать в роли функции.* 
* **Неименованные** - нет имени, через lambda

``` lisp
; (1) Использование именованной
(defun my_square (x) 
    (* x x))

(mapcar #'my_square '(1 2 3 4)) ; -> (1 4 9 16)

; (2) Использование неименованной
(mapcar #'(lambda (x) (* x x)) '(1 2 3 4)) ; -> (1 4 9 16)
```

В (1) функцию нужно искать по имени, в (2) labmda-определение хранится по месту (локальное определение). 

## Базисные функции
**Базис** - это минимально необходимый набор конструкций с помощью которого можно написать программу.   
**Базисные ф-и** - предоставляются языком, минимально необходимые для работы языка.   
* селекторы (car cdr)
* конструкторы (cons)
* предикаты (null, atom, numberp, ..)
* сравнения (eq, eql, equal..)

# Как работают некоторые функции
### quote
' или (quote) - функция, блокирующая вычисления. Нужна для того, чтобы отличить программу от данных.  
#' - функциональная блокировка

### car и cdr
car и cdr являются базовыми функциями доступа к данным.  
  
**car** принимает точечную пару или список в частности в качестве аргумента и возвращает первый элемент(голову; значение по car-указателю) или nil, если на вход был подан пустой список.  

**cdr** принимает точечную пару или список в частности и возвращает хвост(значение по cdr-указателю). 
* В случае аргумента-непустого списка будет возвращен список, состоящий из всех элементов, кроме первого. 
* В случае аргумента-пустого списка возвращается Nil.

``` lisp
(car '(8 . 16)); -> 8
(cdr '(8 . 16)); -> 16

(car '(33 64 2)); -> 33
(cdr '(33 64 2)); -> (64 2)

(car ()); -> Nil
(cdr ()); -> Nil
```

### caadr
(caadr x) - это то же самое, что (car (car (cdr x)))

### cons и list
**cons** создает списковую ячейку и ставит указатели на 2 аргумента, таким образом
объединяя свои аргументы в точечную пару.

В отличие от cons, **list** принимает произвольное число аргументов.
Функция возвращает список, состоящий из значений аргументов.

``` lisp
(cons 4 5); -> (4 . 5)
(cons 4 '(5)); -> (4 5)

(list 4 5); -> (4 5)
(list 4 '(5)); -> (4 (5))
```
### nth и nthcdr
**nth** возвращает значение головы n-й ячейки (нумерация с 0).  
**nthcdr** возвращает значение хвоста n-1-й ячейки.

``` lisp
(nth 2 '(0 1 2 3)); -> 2
(nth 5 '(0 1 2 3)); -> Nil

(nthcdr 2 '(0 1 2 3)); -> (2 3)
(nthcdr 5 '(0 1 2 3)); -> Nil
```

### cond
Ветвление. Сначала просматриваются все предикаты в порядке следования, и если хоть один из них истинный, то cond возвращает результат, связанный с этим предикатом. Если ни один предикат не был истинным, то она вернет Nil.
``` lisp
; Синтаксис:
(cond
    ((условие1) результат1)
    ((условие2) результат2)
    ((условиеN) результатN))
; Пример:
(cond
    ((> 1 2) 5)
    (T 10)
    ((< 1 2) 4)); -> 10
```
*Условия проверяются до первого удовлетворительного.*   
*T - логическая истина*

### Функционалы
[funcall](Функционалы-Lisp#funcall)  
[apply](Функционалы-Lisp#apply)  
[mapcar](Функционалы-Lisp#mapcar)  
[maplist](Функционалы-Lisp#maplist)  